#!/usr/bin/env python3
import sys
import math
import argparse
stack = []
def approx(a, b, tolerance=1.490116e-08): # crude version of all.equal in R
    diff = abs(a - b)
    if diff < tolerance:
        return 1.0
    else:
        return float(diff * b < tolerance)
def d2r(d): # degrees to radians
    return d * math.pi / 180
def r2d(r): # radians to degrees
    return r * 180 / math.pi
def checkstack(n, token): # ensure stack has at least n items
    nstack = len(stack)
    if nstack < n:
        print(f'The stack only has {nstack} items, but {token} requres at least {n} items')
        sys.exit(1)
examples = """Examples:
  rpn e                       # 2.718282 (Euler's number ...)
  rpn e -d 10                 # 2.7182818285 (... to 10 digits.)
  rpn pi                      # 3.141593 (pi is also built-in)
  rpn 10 35                   # [10.0, 35.0] (two items on stack ...)
  rpn 10 35 exch              # [35.0, 10.0] (... exchange those items)
  rpn 10 35 +                 # 45.000000 (addition)
  rpn 10 2 /                  # 5.000000 (divide second-last stack item by last stack item)
  rpn 10 2 x                  # 20.000000 (multiplication, preferred style ...)
  rpn 45 sin                  # 0.707107 (sin, cos, and tan use angle in degrees)
  rpn 1 asin                  # 90.000000 (asin, acos, and atan return an angle in degrees)
  rpn 10 ln                   # 2.302585 (natural log)
  rpn 10 log                  # 1.000000 (base-10 log)
  rpn 10 2 ^                  # 100.000000
  rpn .5 .3 - .3 .1 -         # [0.2, 0.19999999999999998] (not equal but ...)
  rpn .5 .3 - .3 .1 - approx  # 1.000000 (approximately equal)
  rpn .5 .3 - .3 .1 - equal   # 0.000000
  rpn .5 .3 - .3 .1 - -       # 0.000000 (hm, isn't that zero?)
  rpn .5 .3 - .3 .1 - - -d 20 # 0.00000000000000002776 (nope!)

Built-in values
  e, pi

Unary operators (replace last item on stack):
  cos, sin, tan (in degrees),
  cosh, sinh, tanh (not in degrees)
  acos, asin, atan, (in degrees)
  acosh, asinh, atanh, (not in degrees)
  exp, ln, log, sqr, sqrt
  chs, exp, inv

Consuming binary operators (replace second-last item on stack, then remove last item on stack):
  +, -, /, x, ^,
  approx, equal

Non-consuming binary operators (retain stack length):
  exch

Installation:
  Visit http://www.github.com/dankelley/rpn and download `rpn`. Then make
  it executable (with `chmod +x rpn` on unix machines), and put it,
  or an alias, in your unix "path" (I alias it to `~/bin/,rpn` because
  I like using a comma at the start of non-standard local commands.)
"""
parser = argparse.ArgumentParser(prog='rpn',
                                 description='An RPN commandline calculator',
                                 usage='rpn [-h] [-d DIGITS] [-s] tokens',
                                 epilog=examples,
                                 formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument('-d', '--digits', type=int, default=6, help='number of digits to show in final (singleton) result')
parser.add_argument('-s', "--stack", action='store_true', help='show stack during processing')
parser.add_argument("tokens", nargs="+")
options,args = parser.parse_known_args()
tokens = options.tokens
tokenc = len(tokens)
if tokenc == 0:
    print("Error: must supply tokens; try -h for help")
    sys.exit(2)
for i in range(tokenc):
    token = tokens[i]
    slen = len(stack)
    if token == "+":
        checkstack(2, token)
        stack[slen - 2] = float(stack[slen-2]) + float(stack[slen-1])
        stack.pop()
    elif token == "-":
        checkstack(2, token)
        stack[slen - 2] = float(stack[slen-2]) - float(stack[slen-1])
        stack.pop()
    elif token == "x" or token == "*":
        checkstack(2, token)
        stack[slen - 2] = float(stack[slen-2]) * float(stack[slen-1])
        stack.pop()
    elif token == "/":
        checkstack(2, token)
        stack[slen - 2] = float(stack[slen-2]) / float(stack[slen-1])
        stack.pop()
    elif token == "^":
        checkstack(2, token)
        stack[slen - 2] = pow(float(stack[slen-2]), float(stack[slen-1]))
        stack.pop()
    elif token == "equal":
        checkstack(2, token)
        stack[slen - 2] = float(float(stack[slen-2]) == float(stack[slen-1]))
        stack.pop()
    elif token == "approx":
        checkstack(2, token)
        stack[slen - 2] = float(approx(float(stack[slen-2]), float(stack[slen-1])))
        stack.pop()
    elif token == "exch":
        checkstack(2, token)
        tmp = stack[slen - 1]
        stack[slen - 1] = stack[slen - 2]
        stack[slen - 2] = tmp
    elif token == "chs":
        stack[slen - 1] = -(float(stack[slen-1]))
    elif token == "sqrt":
        stack[slen - 1] = math.sqrt(float(stack[slen-1]))
    elif token == "sqr":
        stack[slen - 1] = float(stack[slen-1]) **2
    elif token == "inv":
        stack[slen - 1] = 1.0 / (float(stack[slen-1]))
    elif token == "sin":
        stack[slen - 1] = math.sin(d2r(float(stack[slen-1])))
    elif token == "sinh":
        stack[slen - 1] = math.sinh(float(stack[slen-1]))
    elif token == "asin":
        stack[slen - 1] = r2d(math.asin(float(stack[slen-1])))
    elif token == "asinh":
        stack[slen - 1] = math.asinh(float(stack[slen-1]))
    elif token == "cos":
        stack[slen - 1] = math.cos(d2r(float(stack[slen-1])))
    elif token == "cosh":
        stack[slen - 1] = math.cosh(float(stack[slen-1]))
    elif token == "acos":
        stack[slen - 1] = r2d(math.acos(float(stack[slen-1])))
    elif token == "acosh":
        stack[slen - 1] = math.acosh(float(stack[slen-1]))
    elif token == "tan":
        stack[slen - 1] = math.tan(d2r(float(stack[slen-1])))
    elif token == "tanh":
        stack[slen - 1] = math.tanh(float(stack[slen-1]))
    elif token == "atan":
        stack[slen - 1] = r2d(math.atan(float(stack[slen-1])))
    elif token == "atanh":
        stack[slen - 1] = math.atanh(float(stack[slen-1]))
    elif token == "exp":
        stack[slen - 1] = math.exp(float(stack[slen-1]))
    elif token == "ln":
        stack[slen - 1] = math.log(float(stack[slen-1]))
    elif token == "log":
        stack[slen - 1] = math.log10(float(stack[slen-1]))
    elif token == "pi":
        stack.append(math.pi)
    elif token == "e":
        stack.append(math.e)
    else:
        stack.append(float(token))
    if options.stack:
        print("%6s" % token, stack)

format = f'%.{options.digits}f'
if len(stack) > 1:
    print(stack)
else:
    print(format % float(stack[0]))
