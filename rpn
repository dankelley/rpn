#!/usr/bin/env python3
import sys
import math
import argparse
stack = []
dict = {}
def approx(a, b, tolerance=1.490116e-08): # crude version of all.equal in R
    diff = abs(a - b)
    if diff < tolerance:
        return 1.0
    else:
        return float(diff * b < tolerance)
def checkstack(n, token): # ensure stack has at least n items
    nstack = len(stack)
    if nstack < n:
        print(f'The stack only has {nstack} items, but {token} requres at least {n} items')
        sys.exit(1)
examples = """Examples:
  rpn e                       # 2.718282 (Euler's number ...)
  rpn e -d 10                 # 2.7182818285 (... to 10 digits.)
  rpn pi                      # 3.141593 (pi is also built-in)
  rpn 10 35                   # [10.0, 35.0] (two items on stack ...)
  rpn 10 35 exch              # [35.0, 10.0] (... exchange those items)
  rpn 10 35 +                 # 45.000000 (addition)
  rpn 10 2 /                  # 5.000000 (divide second-last stack item by last stack item)
  rpn 10 2 x                  # 20.000000 (multiplication, preferred style ...)
  rpn 45 sin                  # 0.707107 (sin, cos, and tan use angle in degrees)
  rpn 1 asin                  # 90.000000 (asin, acos, and atan return an angle in degrees)
  rpn 10 ln                   # 2.302585 (natural log)
  rpn 10 log                  # 1.000000 (base-10 log)
  rpn 10 2 ^                  # 100.000000
  # Precise and approximate equality
  rpn .5 .3 - .3 .1 -         # [0.2, 0.19999999999999998] (not equal but ...)
  rpn .5 .3 - .3 .1 - approx  # 1.000000 (approximately equal)
  rpn .5 .3 - .3 .1 - equal   # 0.000000
  rpn .5 .3 - .3 .1 - -       # 0.000000 (hm, isn't that zero?)
  rpn .5 .3 - .3 .1 - - -d 20 # 0.00000000000000002776 (nope!)
  # Definitions
  rpn 100 H def 9.8 G def G H x sqrt # long-wave speed in 100m of water

 Puzzles: guess the meaning of the following
  rpn 45 sin sqr 45 cos sqr +
  rpn 1e-7 Eps def 1 Eps + sqr 1 sqr - Eps /
  # FIXME: let `def` consume whole stack, thus defining a fcn, and redo above

Built-in values
  e, pi

Unary operators (replace last item on stack):
  cos, sin, tan (in degrees),
  cosh, sinh, tanh (not in degrees)
  acos, asin, atan, (in degrees)
  acosh, asinh, atanh, (not in degrees)
  exp, ln, log, sqr, sqrt
  chs, exp, inv

Binary operators:
  +, -, /, x, ^,
  approx, equal

Stack operators:
  exch

Definitional operators:
  def

Development notes:
  I am undecided as to whether `def` should save just the item before
  the name, or everything on the stack.  If the latter, then it could
  be a step towards defining functions.  Will need to update `slen`
  though, and maybe a way to force it to execute the stack after
  that replacement.

Installation:
  Visit http://www.github.com/dankelley/rpn and download `rpn`. Then make
  it executable (with `chmod +x rpn` on unix machines), and put it,
  or an alias, in your unix "path" (I alias it to `~/bin/,rpn` because
  I like using a comma at the start of non-standard local commands.)
"""
parser = argparse.ArgumentParser(prog='rpn',
                                 description='An RPN commandline calculator',
                                 usage='rpn [-h] [-d DIGITS] [-s] tokens',
                                 epilog=examples,
                                 formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument('-d', '--digits', type=int, default=6, help='number of digits to show in final (singleton) result')
parser.add_argument('-s', "--stack", action='store_true', help='show stack during processing')
parser.add_argument("tokens", nargs="+")
options,args = parser.parse_known_args()
tokens = options.tokens
tokenc = len(tokens)
if tokenc == 0:
    print("Error: must supply tokens; try -h for help")
    sys.exit(2)
i = 0
while i < len(tokens):
    token = tokens[i]
    slen = len(stack)
    if token == "+":
        checkstack(2, token)
        stack[slen - 2] = float(stack[slen-2]) + float(stack[slen-1])
        stack.pop()
    elif token == "-":
        checkstack(2, token)
        stack[slen - 2] = float(stack[slen-2]) - float(stack[slen-1])
        stack.pop()
    elif token == "x":
        checkstack(2, token)
        stack[slen - 2] = float(stack[slen-2]) * float(stack[slen-1])
        stack.pop()
    elif token == "/":
        checkstack(2, token)
        stack[slen - 2] = float(stack[slen-2]) / float(stack[slen-1])
        stack.pop()
    elif token == "^":
        checkstack(2, token)
        stack[slen - 2] = pow(float(stack[slen-2]), float(stack[slen-1]))
        stack.pop()
    elif token == "equal":
        checkstack(2, token)
        stack[slen - 2] = float(float(stack[slen-2]) == float(stack[slen-1]))
        stack.pop()
    elif token == "approx":
        checkstack(2, token)
        stack[slen - 2] = float(approx(float(stack[slen-2]), float(stack[slen-1])))
        stack.pop()
    elif token == "exch":
        checkstack(2, token)
        tmp = stack[slen - 1]
        stack[slen - 1] = stack[slen - 2]
        stack[slen - 2] = tmp
    elif token == "chs":
        stack[slen - 1] = -(float(stack[slen-1]))
    elif token == "sqrt":
        stack[slen - 1] = math.sqrt(float(stack[slen-1]))
    elif token == "sqr":
        stack[slen - 1] = float(stack[slen-1]) **2
    elif token == "inv":
        stack[slen - 1] = 1.0 / (float(stack[slen-1]))
    elif token == "sin":
        stack[slen - 1] = math.sin(math.radians(float(stack[slen-1])))
    elif token == "sinh":
        stack[slen - 1] = math.sinh(float(stack[slen-1]))
    elif token == "asin":
        stack[slen - 1] = math.degrees(math.asin(float(stack[slen-1])))
    elif token == "asinh":
        stack[slen - 1] = math.asinh(float(stack[slen-1]))
    elif token == "cos":
        stack[slen - 1] = math.cos(math.radians(float(stack[slen-1])))
    elif token == "cosh":
        stack[slen - 1] = math.cosh(float(stack[slen-1]))
    elif token == "acos":
        stack[slen - 1] = math.degrees(math.acos(float(stack[slen-1])))
    elif token == "acosh":
        stack[slen - 1] = math.acosh(float(stack[slen-1]))
    elif token == "tan":
        stack[slen - 1] = math.tan(math.radians(float(stack[slen-1])))
    elif token == "tanh":
        stack[slen - 1] = math.tanh(float(stack[slen-1]))
    elif token == "atan":
        stack[slen - 1] = math.degrees(math.atan(float(stack[slen-1])))
    elif token == "atanh":
        stack[slen - 1] = math.atanh(float(stack[slen-1]))
    elif token == "exp":
        stack[slen - 1] = math.exp(float(stack[slen-1]))
    elif token == "ln":
        stack[slen - 1] = math.log(float(stack[slen-1]))
    elif token == "log":
        stack[slen - 1] = math.log10(float(stack[slen-1]))
    elif token == "pi":
        stack.append(math.pi)
    elif token == "e":
        stack.append(math.e)
    elif token == "def":
        checkstack(2, token)
        if (stack[slen - 1][0].islower()):
            print(f'cannot "def" to "{stack[slen - 1]}" because it starts with a lower-case letter')
            sys.exit(1)
        dict[stack[slen - 1]] = stack[slen - 2]
        stack.pop()
        stack.pop()
        if options.stack:
            print(dict)
    elif token in dict:
        stack.append(dict[token])
    else:
        stack.append(token)
    if options.stack:
        print("%6s" % token, stack)
    i = i + 1

format = f'%.{options.digits}f'
if len(stack) > 1:
    print(stack)
elif len(stack) == 1:
    print(format % float(stack[0]))
if options.stack:
    print(dict)
