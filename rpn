#!/usr/bin/env python3
import sys
import math
import argparse
stack = []
def approx(a, b, tolerance=1.490116e-08): # crude version of all.equal in R
    diff = abs(a - b)
    if diff < tolerance:
        return 1.0
    else:
        return float(diff * b < tolerance)
def d2r(d): # degrees to radians
    return d * math.pi / 180
def r2d(r): # radians to degrees
    return r * 180 / math.pi
def checkstack(n, arg): # ensure stack has at least n items
    nstack = len(stack)
    if nstack < n:
        print(f'The stack only has {nstack} items, but {arg} requres at least {n} items')
        sys.exit(1)
examples = """Examples:
  rpn e                       # 2.718282 (Euler's number ...)
  rpn e -d 10                 # 2.7182818285 (... to 10 digits.)
  rpn pi                      # 3.141593 (pi is also built-in)
  rpn 10 35                   # [10.0, 35.0] (two items on stack ...)
  rpn 10 35 exch              # [35.0, 10.0] (... exchange those items)
  rpn 10 35 +                 # 45.000000 (addition)
  rpn 10 2 /                  # 5.000000 (divide second-last stack item by last stack item)
  rpn 10 2 x                  # 20.000000 (multiplication, preferred style ...)
  rpn 10 2 \\*                 # 20.0 (... alternate style 2: the \\ is REQUIRED)
  rpn 45 sin                  # 0.707107 (sin, cos, and tan use angle in degrees)
  rpn 1 asin                  # 90.000000 (asin, acos, and atan return an angle in degrees)
  rpn 10 ln                   # 2.302585 (natural log)
  rpn 10 log                  # 1.000000 (base-10 log)
  rpn 10 2 ^                  # 100.000000
  rpn .5 .3 - .3 .1 -         # [0.2, 0.19999999999999998] (not equal but ...)
  rpn .5 .3 - .3 .1 - approx  # 1.000000 (approximately equal)
  rpn .5 .3 - .3 .1 - equal   # 0.000000
  rpn .5 .3 - .3 .1 - -       # 0.000000 (hm, isn't that zero?)
  rpn .5 .3 - .3 .1 - - -d 20 # 0.00000000000000002776 (nope!)

Built-in values
  e, pi

Unary operators (replace last item on stack):
  sin, asin, cos,
  acos, tan, atan,
  exp, ln, log, sqrt
  chs, exp, inv

Binary operators (replace second-last item on stack, then remove last item on stack):
  +, -, /, x (or \\*), ^,
  approx, equal, exch
"""
parser = argparse.ArgumentParser(prog='rpn',
                                 description='An RPN commandline calculator',
                                 epilog=examples,
                                 formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument('-d', '--digits', type=int, default=6, help='number of digits to show in final (singleton) result')
parser.add_argument('-s', "--stack", action='store_true', help='show stack during processing')
options,args = parser.parse_known_args()
argc = len(args)
if argc == 0:
    print("Error: must supply arguments; try -h for help")
    sys.exit(2)
for i in range(argc):
    arg = args[i]
    slen = len(stack)
    if arg == "+":
        checkstack(2, arg)
        stack[slen - 2] = float(stack[slen-2]) + float(stack[slen-1])
        stack.pop()
    elif arg == "-":
        checkstack(2, arg)
        stack[slen - 2] = float(stack[slen-2]) - float(stack[slen-1])
        stack.pop()
    elif arg == "x" or arg == "*":
        checkstack(2, arg)
        stack[slen - 2] = float(stack[slen-2]) * float(stack[slen-1])
        stack.pop()
    elif arg == "/":
        checkstack(2, arg)
        stack[slen - 2] = float(stack[slen-2]) / float(stack[slen-1])
        stack.pop()
    elif arg == "^":
        checkstack(2, arg)
        stack[slen - 2] = pow(float(stack[slen-2]), float(stack[slen-1]))
        stack.pop()
    elif arg == "equal":
        checkstack(2, arg)
        stack[slen - 2] = float(float(stack[slen-2]) == float(stack[slen-1]))
        stack.pop()
    elif arg == "approx":
        checkstack(2, arg)
        stack[slen - 2] = float(approx(float(stack[slen-2]), float(stack[slen-1])))
        stack.pop()
    elif arg == "exch":
        checkstack(2, arg)
        tmp = stack[slen - 1]
        stack[slen - 1] = stack[slen - 2]
        stack[slen - 2] = tmp
    elif arg == "chs":
        stack[slen - 1] = -(float(stack[slen-1]))
    elif arg == "sqrt":
        stack[slen - 1] = math.sqrt(stack[slen-1])
    elif arg == "inv":
        stack[slen - 1] = 1.0 / (float(stack[slen-1]))
    elif arg == "sin":
        stack[slen - 1] = math.sin(d2r(float(stack[slen-1])))
    elif arg == "asin":
        stack[slen - 1] = r2d(math.asin(float(stack[slen-1])))
    elif arg == "cos":
        stack[slen - 1] = math.cos(d2r(float(stack[slen-1])))
    elif arg == "acos":
        stack[slen - 1] = r2d(math.acos(float(stack[slen-1])))
    elif arg == "tan":
        stack[slen - 1] = math.tan(d2r(float(stack[slen-1])))
    elif arg == "atan":
        stack[slen - 1] = r2d(math.atan(float(stack[slen-1])))
    elif arg == "exp":
        stack[slen - 1] = math.exp(float(stack[slen-1]))
    elif arg == "ln":
        stack[slen - 1] = math.log(float(stack[slen-1]))
    elif arg == "log":
        stack[slen - 1] = math.log10(float(stack[slen-1]))
    elif arg == "pi":
        stack.append(math.pi)
    elif arg == "e":
        stack.append(math.e)
    else:
        stack.append(float(arg))
    if options.stack:
        print("%6s" % arg, stack)
format = f'%.{options.digits}f'
if len(stack) > 1:
    print(stack)
else:
    print(format % float(stack[0]))
